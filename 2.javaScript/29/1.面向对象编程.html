<!doctype html>
<html>
	<head>
		<!--声明当前页面的编码集：charset=gbk,gb2312(中文编码)，utf-8国际编码-->
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<!--当前页面的三要素-->
		<meta name="Keywords" content="关键词,关键词">
		<meta name="description" content="">

		<!--css,js-->
		<style type="text/css">
			*{margin:0;padding:0;}
			a{text-decoration:none;color:#fff;}
			ul,li{list-style:none}
			body{font-size:12px;font-family:"微软雅黑";}
			#box{background:red;width:100px;height:100px;}
		</style>

	</head>
<body>
<div id="box"><span>dfddddddddd</span></div>
	


<input type="button" onclick="checkme()" value="点我" />
<script type="text/javascript" src="dom.js"></script>
<script>

	/*checkname:function(){
		
		},
	checkpassword:function(){
	
	}*/

	/*********************************************************/

	//在函数中都是全局的
	/*var tzForm = {
		checkname:function(){
		
		},
		checkpassword:function(){
		
		}
	};
	var donger = {
		checkname:function(){
		
		},
		checkpassword:function(){
		
		}
	};*/
	//但是全局变量名称还是会被覆盖，并且如果共性的重复定义属性和方法

	/*********************************************************/

	//构造函数
	/*var	TzForm = function(){};
	TzForm.checkname = function(){
		alert("1111");
	}
	TzForm.checkPassword = function(){
		alert("222");
	}
	TzForm.checkname();*/

	/*********************************************************/
	//真假对象---全局对象的覆盖，操作的是同一对象
	/*var dom = function(id){//函数表达式
		var domObj = document.getElementById(id);
		return {
			html:function(message){
				return domObj.innerHTML = message;
			},
			text:function(){
				return domObj.innerText || domObj.textContent;
			}
		};
	};
	// function tzForm(){//函数声明
	//	return {};
	//};
	var html = dom("box").html("2222222222222222222222222");
	alert(html);
	var text = dom("box").text();*/

	//这种做饭修改的是同一个内存地址

	/*********************************************************/

	//面向对象的写法 构造函数中定义的属性和方法，在每一个对象创建的时候，会复制一份给当前创建的对象作为它的自有属性
	/*function TzMusic(name){//	类TzMusic和构造函数TzMusic()
		this.play = function(){alert(name);};
		this.stop = function(){};
		this.volume = function(){};
	}*/
	//var music1 = new TzMusic("我爱你中国.mp3");
	//music1.play();//我爱你中国.mp3
	//alert(music1.hasOwnProperty("play"));//true
	//alert("play" in music1);//true
	
	//弊端:会被污染

	//TzMusic("我叫怒放");//没有指向，找到window对象
	//play();//window对象执行

	/*********************************************************/
	//每一个类都拥有prototype子对象，子对象是专门为每一个类创建的对象，用来继承的，这种通过proto扩展的属性和方式是共享的
	//属于对象的公有方法
	function TzMusic(name){
		this.name = name;
	}
	/*TzMusic.prototype.username = "keke";
	TzMusic.prototype.play = function(name){
		alert(name);
	}*/
	
	TzMusic.prototype = {
		constructor:TzMusic,//还原构造函数
		age:30,
		books:["html","js","css"],//引用数据类型
		play:function(){
		
		}
	};
	//格式:类.prototype.属性/方法
	//注意1:通过	 prototype动态给对象扩展和属性和方法，属于公有方法和属性
	//alert(TzMusic.prototype.username);
	
	var music = new TzMusic("keke");
	music.age = 15;
	music.books.push("java");
	alert(music.books);
	//alert(music.name + "===" + music.age);
	//alert(music.hasOwnProperty("name")+"==="+music.hasOwnProperty("age"));
	
	var music2 = new TzMusic("医德");
	//alert(music2.name + "===" + music2.age);
	alert(music2.books);
		
</script>
</body>
</html>